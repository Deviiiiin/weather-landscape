<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>风景新标签页</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; position: relative; }
        
        /* 背景图样式：预加载过渡，避免模糊闪烁 */
        #bg-img {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.8s ease-in-out; /* 平滑淡入 */
        }
        #bg-img.visible {
            opacity: 1;
        }

        /* 加载提示：简洁不遮挡 */
        #loading-tip {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 16px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            z-index: 20;
            display: none;
        }
    </style>
</head>
<body>
    <!-- 高清兜底图：选压缩均衡的large尺寸，确保初始清晰 -->
    <img id="bg-img" alt="天气+时段匹配风景" src="https://images.pexels.com/photos/1640774/pexels-photo-1640774.jpeg?auto=compress&cs=tinysrgb&w=1600">
    <div id="loading-tip">加载中...</div>

    <script>
        // 1. API Key（保持不变）
        const PEXELS_API_KEY = "lqOaQCzRbfr0BDueszU1hf1ZSQCmKdx1ifiVvDWUDIC1Xn8MZMmyh5rl";
        const WEATHER_API_KEY = "8196f3fc5ba63922bb1e35265baadb35";

        // 2. 时段配置（保持不变）
        const TIME_PERIODS = [
            { start: 21, end: 2, name: "深夜", desc: "星空静谧" },
            { start: 2, end: 5, name: "凌晨", desc: "万籁俱静" },
            { start: 5, end: 7, name: "清晨", desc: "微光薄雾" },
            { start: 7, end: 12, name: "上午", desc: "明亮清新" },
            { start: 12, end: 17, name: "下午", desc: "晴空暖阳" },
            { start: 17, end: 21, name: "傍晚", desc: "晚霞鎏金" }
        ];

        // 3. 天气映射：去掉滤镜感关键词，保留原生高清
        const WEATHER_MAPPING = {
            Clear: { titleSuffix: "·晴空万里", keywords: "clear sky, bright sun, vibrant landscape, blue sky nature, natural, high resolution" },
            Clouds: { titleSuffix: "·云卷云舒", keywords: "cloudy sky, overcast landscape, soft light nature, misty cloud, natural, high resolution" },
            Rain: { titleSuffix: "·烟雨朦胧", keywords: "rainy landscape, misty forest, rainy day nature, wet ground, light rain, natural, high resolution" },
            Drizzle: { titleSuffix: "·细雨绵绵", keywords: "light drizzle, gentle rain, misty nature, damp landscape, natural, high resolution" },
            Thunderstorm: { titleSuffix: "·雷雨磅礴", keywords: "thunderstorm, dramatic sky, dark clouds, rainstorm landscape, natural, high resolution" },
            Snow: { titleSuffix: "·白雪皑皑", keywords: "snowy landscape, winter snow, white nature, snow-covered mountain, natural, high resolution" },
            Fog: { titleSuffix: "·雾锁山河", keywords: "foggy landscape, misty mountain, fog nature, hazy scenery, natural, high resolution" },
            Mist: { titleSuffix: "·薄雾缭绕", keywords: "misty landscape, light fog, hazy nature, soft focus scenery, natural, high resolution" },
            Smoke: { titleSuffix: "·烟岚缥缈", keywords: "smoky landscape, hazy sky, misty nature, soft smoke scenery, natural, high resolution" },
            Haze: { titleSuffix: "·轻霾笼山", keywords: "hazy landscape, soft light nature, muted colors scenery, natural, high resolution" }
        };

        // 4. 优化去重逻辑：全局去重+当日时段缓存（保持不变，满足你的需求）
        const STORAGE_KEYS = {
            GLOBAL_USED_PHOTOS: "global-used-photo-ids", // 全局历史图片ID（永久去重）
            DAILY_PERIOD_PHOTO: "daily-period-current-photo" // 当日时段图片缓存（当天同时段不刷新）
        };

        // 获取全局已使用图片ID（永久去重）
        function getGlobalUsedPhotoIds() {
            const stored = localStorage.getItem(STORAGE_KEYS.GLOBAL_USED_PHOTOS);
            return stored ? JSON.parse(stored) : [];
        }

        // 保存全局已使用图片ID（上限200张，避免存储过大）
        function saveGlobalUsedPhotoId(photoId) {
            let usedIds = getGlobalUsedPhotoIds();
            if (!usedIds.includes(photoId)) {
                usedIds.push(photoId);
                if (usedIds.length > 200) usedIds.shift(); // 超过200张，删除最早的
                localStorage.setItem(STORAGE_KEYS.GLOBAL_USED_PHOTOS, JSON.stringify(usedIds));
            }
        }

        // 获取当日时段缓存图片
        function getDailyPeriodCachedPhoto() {
            const stored = localStorage.getItem(STORAGE_KEYS.DAILY_PERIOD_PHOTO);
            if (!stored) return null;
            return JSON.parse(stored);
        }

        // 保存当日时段缓存图片
        function saveDailyPeriodCachedPhoto(photoData) {
            const today = getCurrentDateStr();
            const period = getCurrentPeriod().name;
            const data = {
                date: today,
                period: period,
                photoId: photoData.id,
                imgUrl: photoData.url
            };
            localStorage.setItem(STORAGE_KEYS.DAILY_PERIOD_PHOTO, JSON.stringify(data));
        }

        // 辅助工具：获取当前日期字符串（格式：20251224）
        function getCurrentDateStr() {
            const date = new Date();
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            return `${year}${month}${day}`;
        }

        // 5. 获取当前时段（保持不变）
        function getCurrentPeriod() {
            const hour = new Date().getHours();
            for (const period of TIME_PERIODS) {
                if (period.start <= period.end ? (hour >= period.start && hour < period.end) : (hour >= period.start || hour < period.end)) {
                    return period;
                }
            }
            return TIME_PERIODS[3]; // 兜底：上午
        }

        // 6. 天气缓存（1小时过期，保持不变）
        const WEATHER_CACHE_KEY = "cached-weather-data";
        const WEATHER_CACHE_EXPIRE = 3600000;
        function getCachedWeather() {
            const cached = localStorage.getItem(WEATHER_CACHE_KEY);
            if (!cached) return null;
            const { data, timestamp } = JSON.parse(cached);
            if (Date.now() - timestamp < WEATHER_CACHE_EXPIRE) return data;
            localStorage.removeItem(WEATHER_CACHE_KEY);
            return null;
        }
        function saveWeatherCache(weatherData) {
            localStorage.setItem(WEATHER_CACHE_KEY, JSON.stringify({
                data: weatherData,
                timestamp: Date.now()
            }));
        }

        // 7. 定位+天气获取（保持不变）
        async function getWeatherData() {
            const cachedWeather = getCachedWeather();
            if (cachedWeather) return cachedWeather;

            let location;
            try {
                location = await Promise.race([
                    getUserLocation(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error("定位超时")), 10000))
                ]);
            } catch (error) {
                console.log("定位失败，使用默认天气：", error.message);
                const defaultWeather = { main: "Clear", description: "晴", temp: 25 };
                saveWeatherCache(defaultWeather);
                return defaultWeather;
            }

            try {
                const weatherRes = await Promise.race([
                    fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${location.lat}&lon=${location.lon}&appid=${WEATHER_API_KEY}&units=metric&lang=zh_cn`),
                    new Promise((_, reject) => setTimeout(() => reject(new Error("天气API超时")), 10000))
                ]);
                if (!weatherRes.ok) throw new Error("天气数据获取失败");
                const weatherData = await weatherRes.json();
                const result = {
                    main: weatherData.weather[0].main,
                    description: weatherData.weather[0].description,
                    temp: Math.round(weatherData.main.temp)
                };
                saveWeatherCache(result);
                return result;
            } catch (error) {
                console.log("天气API失败，使用默认天气：", error.message);
                const defaultWeather = { main: "Clear", description: "晴", temp: 25 };
                saveWeatherCache(defaultWeather);
                return defaultWeather;
            }
        }

        // 定位函数（简化）
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error("浏览器不支持定位"));
                    return;
                }
                navigator.geolocation.getCurrentPosition(
                    (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                    (err) => reject(new Error(`定位拒绝：${err.message}`))
                );
            });
        }

        // 8. 生成组合数据（关键词调整为原生高清）
        async function getCombinedData() {
            const period = getCurrentPeriod();
            const weather = await getWeatherData();
            const weatherConfig = WEATHER_MAPPING[weather.main] || WEATHER_MAPPING.Clear;
            
            const periodKeywords = {
                "深夜": "night sky, stars, natural, high resolution",
                "凌晨": "deep night, dark mountain, natural, high resolution",
                "清晨": "dawn glow, first light, natural, high resolution",
                "上午": "fresh green forest, sunny meadow, natural, high resolution",
                "下午": "blue sea, clear mountain, natural, high resolution",
                "傍晚": "sunset, evening glow, natural, high resolution"
            }[period.name];

            return {
                title: `${period.name}${weatherConfig.titleSuffix}`,
                keywords: `${weatherConfig.keywords}, ${periodKeywords}`,
                weatherMain: weather.main
            };
        }

        // 9. 核心优化：回归large尺寸（压缩均衡更清晰）+ 原生高清筛选
        const bgImg = document.getElementById('bg-img');
        const loadingTip = document.getElementById('loading-tip');
        let combinedData = null;

        // 预加载图片（确保加载完成后再显示，避免模糊）
        function preloadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = url;
                img.onload = () => {
                    // 清晰度校验：至少1600x900（large尺寸的优质分辨率）
                    if (img.naturalWidth >= 1600 && img.naturalHeight >= 900) {
                        resolve(url);
                    } else {
                        reject(new Error("图片分辨率不足，重新加载"));
                    }
                };
                img.onerror = () => reject(new Error("图片加载失败"));
            });
        }

        // 从Pexels获取优质large尺寸图片（压缩均衡，视觉更清晰）
        async function fetchHighQualityPhoto(keywords) {
            const globalUsedIds = getGlobalUsedPhotoIds();
            let page = 1;
            const maxPages = 10; // 最多尝试10页，避免无限循环

            while (page <= maxPages) {
                try {
                    const res = await fetch(`https://api.pexels.com/v1/search?query=${keywords}&per_page=15&page=${page}`, {
                        headers: { Authorization: PEXELS_API_KEY }
                    });

                    if (!res.ok) throw new Error(`Pexels API请求失败：${res.status}`);
                    const data = await res.json();
                    if (!data.photos || data.photos.length === 0) throw new Error("无匹配图片");

                    // 筛选：未在全局去重列表中，且large尺寸优质
                    const availablePhotos = data.photos.filter(photo => 
                        !globalUsedIds.includes(photo.id.toString()) && 
                        photo.src.large && // 确保有large尺寸
                        photo.width >= 1600 && photo.height >= 900 // 原生分辨率达标
                    );

                    if (availablePhotos.length > 0) {
                        const randomPhoto = availablePhotos[Math.floor(Math.random() * availablePhotos.length)];
                        const imgUrl = randomPhoto.src.large; // 用large尺寸（压缩均衡，视觉更清晰）
                        const photoId = randomPhoto.id.toString();
                        return { imgUrl, photoId };
                    }

                    page++; // 当前页无可用图片，翻下一页
                } catch (error) {
                    console.log("获取图片失败：", error.message);
                    page++;
                }
            }

            // 兜底高清图（large尺寸，压缩均衡）
            return {
                imgUrl: "https://images.pexels.com/photos/1640774/pexels-photo-1640774.jpeg?auto=compress&cs=tinysrgb&w=1600",
                photoId: "fallback-1640774"
            };
        }

        // 主加载函数（保持去重逻辑不变）
        async function loadBackgroundImage() {
            loadingTip.style.display = "block";
            bgImg.classList.remove("visible"); // 隐藏当前图片，准备加载新图

            try {
                // 1. 先查当日时段缓存：同一天同时段直接复用
                const dailyCache = getDailyPeriodCachedPhoto();
                const today = getCurrentDateStr();
                const currentPeriod = getCurrentPeriod().name;

                if (dailyCache && dailyCache.date === today && dailyCache.period === currentPeriod) {
                    // 校验缓存图片是否有效
                    const globalUsedIds = getGlobalUsedPhotoIds();
                    if (!globalUsedIds.includes(dailyCache.photoId)) {
                        await preloadImage(dailyCache.imgUrl);
                        bgImg.src = dailyCache.imgUrl;
                        bgImg.classList.add("visible");
                        loadingTip.style.display = "none";
                        return;
                    }
                }

                // 2. 无缓存/缓存失效，获取新图片
                if (!combinedData) {
                    combinedData = await getCombinedData();
                    document.title = combinedData.title;
                }

                const { keywords } = combinedData;
                const { imgUrl, photoId } = await fetchHighQualityPhoto(keywords);
                await preloadImage(imgUrl);
                bgImg.src = imgUrl;
                saveDailyPeriodCachedPhoto({ id: photoId, url: imgUrl });
                saveGlobalUsedPhotoId(photoId);
                bgImg.classList.add("visible");

            } catch (error) {
                console.log("加载图片异常，使用兜底图：", error.message);
                bgImg.src = "https://images.pexels.com/photos/1640774/pexels-photo-1640774.jpeg?auto=compress&cs=tinysrgb&w=1600";
                bgImg.classList.add("visible");
            } finally {
                loadingTip.style.display = "none";
            }
        }

        // 初始化加载
        window.addEventListener("load", () => {
            loadBackgroundImage();
        });
    </script>
</body>
</html>
