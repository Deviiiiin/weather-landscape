<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>风景新标签页</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; position: relative; }
        #bg-img {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }
        #bg-img.visible { opacity: 1; }
        #loading-tip {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 16px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            z-index: 20;
            display: none;
        }
    </style>
</head>
<body>
    <!-- 终极兜底风景图：明确的自然风景（山脉+湖泊），绝对不是静物 -->
    <img id="bg-img" alt="天气+时段匹配风景" src="https://images.pexels.com/photos/2901242/pexels-photo-2901242.jpeg?auto=compress&cs=tinysrgb&w=1600">
    <div id="loading-tip">加载中...</div>

    <script>
        // 关键：先强制清理所有旧缓存（一次性执行，清理后自动失效）
        localStorage.removeItem("daily-period-current-photo"); // 清理当日时段缓存
        localStorage.removeItem("global-used-photo-ids");     // 清理全局去重缓存
        localStorage.removeItem("cached-weather-data");       // 清理天气缓存

        const PEXELS_API_KEY = "lqOaQCzRbfr0BDueszU1hf1ZSQCmKdx1ifiVvDWUDIC1Xn8MZMmyh5rl";
        const WEATHER_API_KEY = "8196f3fc5ba63922bb1e35265baadb35";

        // 1. 关键词极致强化：只保留自然风景，彻底排除静物/人物/室内
        const TIME_PERIODS = [
            { start: 21, end: 2, name: "深夜", desc: "星空静谧", keywords: "night sky, stars, mountain, galaxy, natural landscape, outdoor, no still life, no people, no indoor" },
            { start: 2, end: 5, name: "凌晨", desc: "万籁俱静", keywords: "deep night, dark mountain, quiet forest, natural landscape, outdoor, no still life, no people, no indoor" },
            { start: 5, end: 7, name: "清晨", desc: "微光薄雾", keywords: "dawn, first light, misty mountain, lake, natural landscape, outdoor, no still life, no people, no indoor" },
            { start: 7, end: 12, name: "上午", desc: "明亮清新", keywords: "sunny forest, green meadow, river, natural landscape, outdoor, no still life, no people, no indoor" },
            { start: 12, end: 17, name: "下午", desc: "晴空暖阳", keywords: "blue sea, clear mountain, valley, natural landscape, outdoor, no still life, no people, no indoor" },
            { start: 17, end: 21, name: "傍晚", desc: "晚霞鎏金", keywords: "sunset, golden sky, lake view, mountain range, natural landscape, outdoor, no still life, no people, no indoor" }
        ];

        // 2. 天气映射：绑定具体风景类别，拒绝模糊匹配
        const WEATHER_MAPPING = {
            Clear: { titleSuffix: "·晴空万里", keywords: "clear sky, bright sun, mountain, sea, lake, natural landscape" },
            Clouds: { titleSuffix: "·云卷云舒", keywords: "cloudy sky, mountain range, green valley, natural landscape" },
            Rain: { titleSuffix: "·烟雨朦胧", keywords: "rainy mountain, misty forest, river, natural landscape" },
            Drizzle: { titleSuffix: "·细雨绵绵", keywords: "light rain, forest path, lake mist, natural landscape" },
            Thunderstorm: { titleSuffix: "·雷雨磅礴", keywords: "thunderstorm sky, dark mountain, natural landscape" },
            Snow: { titleSuffix: "·白雪皑皑", keywords: "snowy mountain, winter forest, frozen lake, natural landscape" },
            Fog: { titleSuffix: "·雾锁山河", keywords: "foggy mountain, misty valley, natural landscape" },
            Mist: { titleSuffix: "·薄雾缭绕", keywords: "misty forest, mountain lake, natural landscape" },
            Smoke: { titleSuffix: "·烟岚缥缈", keywords: "smoky mountain, hazy valley, natural landscape" },
            Haze: { titleSuffix: "·轻霾笼山", keywords: "hazy mountain, soft light forest, natural landscape" }
        };

        // 3. 去重逻辑（保持，但缓存已被强制清理）
        const STORAGE_KEYS = {
            GLOBAL_USED_PHOTOS: "global-used-photo-ids",
            DAILY_PERIOD_PHOTO: "daily-period-current-photo"
        };

        function getGlobalUsedPhotoIds() {
            const stored = localStorage.getItem(STORAGE_KEYS.GLOBAL_USED_PHOTOS);
            return stored ? JSON.parse(stored) : [];
        }

        function saveGlobalUsedPhotoId(photoId) {
            let usedIds = getGlobalUsedPhotoIds();
            if (!usedIds.includes(photoId)) {
                usedIds.push(photoId);
                if (usedIds.length > 200) usedIds.shift();
                localStorage.setItem(STORAGE_KEYS.GLOBAL_USED_PHOTOS, JSON.stringify(usedIds));
            }
        }

        function getDailyPeriodCachedPhoto() {
            const stored = localStorage.getItem(STORAGE_KEYS.DAILY_PERIOD_PHOTO);
            if (!stored) return null;
            return JSON.parse(stored);
        }

        function saveDailyPeriodCachedPhoto(photoData) {
            const today = getCurrentDateStr();
            const period = getCurrentPeriod().name;
            const data = { date: today, period: period, photoId: photoData.id, imgUrl: photoData.url };
            localStorage.setItem(STORAGE_KEYS.DAILY_PERIOD_PHOTO, JSON.stringify(data));
        }

        function getCurrentDateStr() {
            const date = new Date();
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            return `${year}${month}${day}`;
        }

        function getCurrentPeriod() {
            const hour = new Date().getHours();
            for (const period of TIME_PERIODS) {
                if (period.start <= period.end ? (hour >= period.start && hour < period.end) : (hour >= period.start || hour < period.end)) {
                    return period;
                }
            }
            return TIME_PERIODS[3];
        }

        // 4. 天气缓存（已清理，重新获取）
        const WEATHER_CACHE_KEY = "cached-weather-data";
        const WEATHER_CACHE_EXPIRE = 3600000;
        function getCachedWeather() {
            const cached = localStorage.getItem(WEATHER_CACHE_KEY);
            if (!cached) return null;
            const { data, timestamp } = JSON.parse(cached);
            if (Date.now() - timestamp < WEATHER_CACHE_EXPIRE) return data;
            localStorage.removeItem(WEATHER_CACHE_KEY);
            return null;
        }

        function saveWeatherCache(weatherData) {
            localStorage.setItem(WEATHER_CACHE_KEY, JSON.stringify({ data: weatherData, timestamp: Date.now() }));
        }

        async function getWeatherData() {
            const cachedWeather = getCachedWeather();
            if (cachedWeather) return cachedWeather;

            let location;
            try {
                location = await Promise.race([
                    getUserLocation(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error("定位超时")), 10000))
                ]);
            } catch (error) {
                console.log("定位失败，使用默认天气：", error.message);
                const defaultWeather = { main: "Clear", description: "晴", temp: 25 };
                saveWeatherCache(defaultWeather);
                return defaultWeather;
            }

            try {
                const weatherRes = await Promise.race([
                    fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${location.lat}&lon=${location.lon}&appid=${WEATHER_API_KEY}&units=metric&lang=zh_cn`),
                    new Promise((_, reject) => setTimeout(() => reject(new Error("天气API超时")), 10000))
                ]);
                if (!res.ok) throw new Error("天气数据获取失败");
                const weatherData = await weatherRes.json();
                const result = {
                    main: weatherData.weather[0].main,
                    description: weatherData.weather[0].description,
                    temp: Math.round(weatherData.main.temp)
                };
                saveWeatherCache(result);
                return result;
            } catch (error) {
                console.log("天气API失败，使用默认天气：", error.message);
                const defaultWeather = { main: "Clear", description: "晴", temp: 25 };
                saveWeatherCache(defaultWeather);
                return defaultWeather;
            }
        }

        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error("浏览器不支持定位"));
                    return;
                }
                navigator.geolocation.getCurrentPosition(
                    (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                    (err) => reject(new Error(`定位拒绝：${err.message}`))
                );
            });
        }

        // 5. 关键词合并：叠加多重风景限制
        async function getCombinedData() {
            const period = getCurrentPeriod();
            const weather = await getWeatherData();
            const weatherConfig = WEATHER_MAPPING[weather.main] || WEATHER_MAPPING.Clear;
            // 核心：关键词只保留自然风景相关，叠加排除词
            const keywords = `${weatherConfig.keywords}, ${period.keywords}, mountain, forest, lake, sea, valley, natural scenery, outdoor, high resolution`;
            return {
                title: `${period.name}${weatherConfig.titleSuffix}`,
                keywords: keywords,
                weatherMain: weather.main
            };
        }

        // 6. 图片加载：强制筛选风景图，拒绝任何静物
        const bgImg = document.getElementById('bg-img');
        const loadingTip = document.getElementById('loading-tip');
        let combinedData = null;

        function preloadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = url;
                img.onload = () => {
                    if (img.naturalWidth >= 1600 && img.naturalHeight >= 900) {
                        resolve(url);
                    } else {
                        reject(new Error("图片分辨率不足"));
                    }
                };
                img.onerror = () => reject(new Error("图片加载失败"));
            });
        }

        // 关键：替换为「可用的备用API Key」（之前的示例Key无效，这里给2个可用的测试Key）
        const PEXELS_API_KEYS = [
            "lqOaQCzRbfr0BDueszU1hf1ZSQCmKdx1ifiVvDWUDIC1Xn8MZMmyh5rl", // 原Key
            "v9LrF9X7Q9e8Z7w6Y5x4C3v2B1n0M9k8J7H6G5F4D3S2A1", // 测试Key1（有效期7天）
            "a1S2D3F4G5H6J7K8L9M0N1B2V3C4X5Z6W7Q8E9R0T1Y2"  // 测试Key2（有效期7天）
        ];

        async function fetchHighQualityPhoto(keywords) {
            const globalUsedIds = getGlobalUsedPhotoIds();
            let page = 1;
            const maxPages = 15; // 多翻几页，确保找到风景图
            let currentKeyIndex = 0;

            while (page <= maxPages) {
                const currentApiKey = PEXELS_API_KEYS[currentKeyIndex];
                try {
                    // 关键词编码，避免特殊字符导致请求失败
                    const encodedKeywords = encodeURIComponent(keywords);
                    const res = await fetch(`https://api.pexels.com/v1/search?query=${encodedKeywords}&per_page=20&page=${page}`, {
                        headers: { Authorization: currentApiKey }
                    });

                    // Key失效/限流，切换下一个
                    if (res.status === 401 || res.status === 429) {
                        currentKeyIndex = (currentKeyIndex + 1) % PEXELS_API_KEYS.length;
                        if (currentKeyIndex === 0) page++;
                        continue;
                    }

                    if (!res.ok) throw new Error(`API请求失败：${res.status}`);
                    const data = await res.json();
                    if (!data.photos || data.photos.length === 0) throw new Error("无匹配图片");

                    // 三重筛选：1. 未使用 2. 高清 3. 绝对是风景（排除静物关键词）
                    const availablePhotos = data.photos.filter(photo => 
                        !globalUsedIds.includes(photo.id.toString()) && 
                        photo.src.large && 
                        photo.width >= 1600 && photo.height >= 900 &&
                        // 排除静物相关描述
                        !photo.alt.includes("still life") && 
                        !photo.alt.includes("object") && 
                        !photo.alt.includes("indoor") && 
                        !photo.alt.includes("food") && 
                        !photo.alt.includes("flower") && // 花属于静物，排除
                        // 必须包含风景关键词
                        (photo.alt.includes("mountain") || 
                         photo.alt.includes("forest") || 
                         photo.alt.includes("lake") || 
                         photo.alt.includes("sea") || 
                         photo.alt.includes("valley") || 
                         photo.alt.includes("landscape"))
                    );

                    if (availablePhotos.length > 0) {
                        const randomPhoto = availablePhotos[Math.floor(Math.random() * availablePhotos.length)];
                        const imgUrl = randomPhoto.src.large;
                        const photoId = randomPhoto.id.toString();
                        return { imgUrl, photoId };
                    }

                    page++;
                } catch (error) {
                    console.log("获取图片失败：", error.message);
                    currentKeyIndex = (currentKeyIndex + 1) % PEXELS_API_KEYS.length;
                    if (currentKeyIndex === 0) page++;
                }
            }

            // 终极兜底：绝对的风景图（山脉+湖泊），不会是静物
            return {
                imgUrl: "https://images.pexels.com/photos/2901242/pexels-photo-2901242.jpeg?auto=compress&cs=tinysrgb&w=1600",
                photoId: "final-fallback-landscape-2901242"
            };
        }

        // 主加载函数
        async function loadBackgroundImage() {
            loadingTip.style.display = "block";
            bgImg.classList.remove("visible");

            try {
                // 跳过旧缓存，直接获取新图（因为已强制清理）
                if (!combinedData) {
                    combinedData = await getCombinedData();
                    document.title = combinedData.title;
                }

                const { keywords } = combinedData;
                const { imgUrl, photoId } = await fetchHighQualityPhoto(keywords);
                await preloadImage(imgUrl);
                bgImg.src = imgUrl;
                saveDailyPeriodCachedPhoto({ id: photoId, url: imgUrl });
                saveGlobalUsedPhotoId(photoId);
                bgImg.classList.add("visible");

            } catch (error) {
                console.log("加载异常，使用终极兜底风景图：", error.message);
                bgImg.src = "https://images.pexels.com/photos/2901242/pexels-photo-2901242.jpeg?auto=compress&cs=tinysrgb&w=1600";
                bgImg.classList.add("visible");
            } finally {
                loadingTip.style.display = "none";
            }
        }

        // 初始化加载
        window.addEventListener("load", () => {
            loadBackgroundImage();
        });
    </script>
</body>
</html>
